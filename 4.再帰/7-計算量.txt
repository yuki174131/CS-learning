計算量には、以下2種類に分けられる
- 時間的にどれほど手間を要したか
- 空間的にどれほど手間を要したか

コンピュータが特定の手順に従って与えられた問題を解く際に必要とする手順の回数のことを時間計算量といい、
必要とする記憶領域の容量のことを空間計算量という。

入力のサイズ n に対して、アルゴリズムがどれくらい時間がかかるか予測を立てるために、
コンピュータサイエンスでは O ( n ) , O ( n 2 ) , O ( 2 n ) , O ( log n ) のような 
O 記法（Bachmann-Landau O-notation）と呼ばれる記号を頻繁に使う。

例1. 1 + 2 + 3 + … + n を再帰的に計算するアルゴリズム。

function summation(n: number): number {
  if (n <= 0) return 0;
  return summation(n - 1) + n;
}
// 使用例
console.log(summation(5)); // 結果: 15

この関数は、ベースケースに到達するまでに n 回再帰的に呼び出されているので、
最初の呼び出しを含めて、時間計算量は O ( n + 1 ) ≒ O ( n ) と表現される。
またコールスタックに再帰関数が、最初に呼び出された関数の上に n 個積み上がることから、
空間計算量も O ( n + 1 ) ≒ O ( n ) と表現されます。

例2. n を受け取り、3 未満になるまで 3 を再帰的に引き続けるアルゴリズム。

function subtractBy3Count(n: number): number {
  if (n < 3) return 0;
  return 1 + subtractBy3Count(n - 3);
}
// 使用例
console.log(subtractBy3Count(12)); // 結果: 4

n が 12 のとき、subtractBy3Count(12) -> subtractBy3Count(9) -> subtractBy3Count(6) -> 
subtractBy3Count(3) -> subtractBy3Count(0) のように、
n / 3 回再帰関数が呼ばれる。時間計算量は、最初の呼び出しも含めて O ((n / 3) + 1) ≒ O(n) と表現される。
空間計算量も同様に O(n) と表現されます。
※O記法では定数や係数は全て無視

例 3. n を受け取り、1 以下になるまで 3 で再帰的に割り続けるアルゴリズム。

function divideBy3Count(n: number): number {
  if (n <= 1) return 0;
  return 1 + divideBy3Count(n / 3);
}

// 使用例
console.log(divideBy3Count(243)); // 結果: 4

例えば、n が 243 のとき、 divideBy3Count(243) -> divideBy3Count(81) -> divideBy3Count(27) -> … 
のように、関数を呼び出すために引数を3で割っているので、時間計算量は O(log3n + 1 ) ≒ O(logn)と表現される。
空間計算量もO(logn)と表現される。

Note:（divideByCount の時間計算量がO(logn)の理由）
x = ap のうち、p を指数と呼びます。一方、p = log^a x のうち、p を対数と呼ぶ。
つまり、3^5 = 243のように、指数は 1 つの数を何回かけるかを表し、対数を使うことで、
他の 2 つの値から指数を求めることができる。つまり、3 を何乗すれば 243 になるかは、3 と 243 を用いて 
log^3 243 と表現される。
したがって、指数と対数には逆の関係が成り立つ。今回の divideBy3Count の例で、n = 243 として、関数を実行。
divideBy3Count(243) -> divideBy3Count(81) -> divideBy3Count(27) -> divideBy3Count(9) -> divideBy3Count(3) -> divideBy3Count(1) 
divideBy3Count(243) は自身を log^3 243 、つまり 5 回呼び出した。
つまり、時間計算量は O (logn) であり、コールスタックの高さから、空間計算量も O(logn) とわかる。

これまで O(n) , O(n^2) , O (log n) , O(2n) が登場しました。
入力サイズ n を変えて、それぞれの値がどれほど変化するか確かめてみましょう。ここでは log n は底を 2 とします。

n         | O(n)          | O(n^2)           | O(log n)     | O(2^n)
-------------------------------------------------------------------------
5         | 5             | 25               | 2            | 32
10        | 10            | 100              | 3            | 1,024
20        | 20            | 400              | 4            | 1,048,576
50        | 50            | 2,500            | 5            | ~10^15
100       | 100           | 10,000           | 6            | ~10^30
1,000     | 1,000         | 1,000,000        | 9            | ~10^300
10,000    | 10,000        | 100,000,000      | 13           | ~10^3,000
100,000   | 100,000       | ~10^10           | 16           | ~10^30,000
1,000,000 | 1,000,000     | ~10^12           | 19           | ~10^300,000

O(log n) はnがとてつもなく大きくなっても、わずかの計算回数で済む。