木構造の走査（traverse）とは、木の各ノード（点や要素）を 1 回ずつ、特定の規則に従って見て回ることを意味する。
これは、人が公園の全ての木を見て回るようなイメージです。この走査は、順番に全てのノードを訪れるため、n 個のノードがある場合、n 回の操作が必要となり、O(n) の時間計算量を必要とする。
また、この走査操作は walk とも呼ばれる。

深さ優先走査
深さ優先探索（depth-first search: DFS）は、グラフや木構造を走査するためのアルゴリズム。
この探索方法は、現在の頂点（ノード）から接続している未訪問の頂点へ進み、進むことができなくなったときに初めて戻るという戦略を採用する。
具体的には、深さ優先探索は次のような手順を取る。

初期ノードから探索を開始。
現在のノードに隣接する未訪問のノードがある場合は、そのノードを訪問し、そのノードを新たな「現在のノード」とします。そして、ステップ 2 を再度行う。
現在のノードに隣接する未訪問のノードがない場合は、直前に訪れたノードに戻ります。そして、ステップ 2 を再度行う。
全てのノードを訪問するか、または目的のノードが見つかった場合に探索を終了する。
深さ優先探索は、たとえば迷路の解を見つける場合や、チェスの最適解をを探索する場合など、ある状態から始めてその「深さ」（つまり、それ以降に続く可能性のある状態）を全て探索する際に役立つ。

幅優先走査
幅優先探索（breadth-first search: BFS）は、グラフや木構造の探索を行うためのアルゴリズム。
深さ優先探索が一つの経路を深く探索していくのに対して、幅優先探索は現在地点から「幅」方向、すなわち同じ階層にあるノードに対して探索を進める。

具体的には、幅優先探索は次の手順で実行される。

初期ノードを訪問し、訪問済みのリストやキューに追加する。
現在のノードに隣接する未訪問のノード全てを訪問し、それぞれを訪問済みのリストやキューに追加する。
全ての隣接ノードを訪問した後、キューから次のノードを取り出し、それを新たな「現在のノード」とする。そして、ステップ 2 を再度行う。
全てのノードを訪問するか、または目的のノードが見つかった場合に探索を終了する。
幅優先探索は、グラフ上の最短経路問題や、マルチプレイヤーオンラインゲームのマッチングシステム等、多くの実用的なアプリケーションで利用されている。
この探索手法は、ノード間の距離が一様である場合に特に有用で、その場合、最初に見つかった経路が最短経路となる。