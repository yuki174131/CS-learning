二分木（binary tree）は、データ構造の 1 つ。根付き木構造の中で、あるノードが持つ子の数が最大で 2 であるものを指す。
これらの子ノードは通常、「左の子ノード」と「右の子ノード」呼ばれます。
この木にはデータが 1 つも含まれていない場合もあり、その場合は「空の木」と呼ばれます。

このような二分木構造は、特にデータの探索において便利。なぜなら、探索する時間がデータの数の対数（log n）になるからである。
つまり、大量のデータを効率的に探索できるの。

具体的には、例えば二分探索木（BST：Binary Search Tree）などのように、二分木が特定の順序で構成されている場合、探索する際に次に見るべきノードが
「左の子ノード」か「右の子ノード」かをそのノードの値と探す値を比較することで決定できます。つまり、それぞれの探索ステップで探索範囲が半分になるため、探索時間はデータの数（n）の対数（log n）になる。

また、二分木はその自然な形状から、再帰的な問題を解くのにもよく使われる。実際、二分木の構造や操作を扱う場合、再帰を使うと最も直感的にプログラムを書くことができる。

二分木は、それぞれのノードが最大で　2　つの子ノードを持つことができる構造のことを指す。これにはいくつかのバリエーションがある。

全二分木

全てのノードが「葉（子を持たないノード）であるか、もしくは2つの子を持っている」二分木のことを言う。つまり、ノードは子を持つか持たないかのどちらかで、1 つだけ子を持つようなノードは存在しない。

完全二分木

この中でも、全ての葉ノードが同じ「深さ」を持つ二分木は、完全二分木（perfect binary tree）と呼ばれる。
これは、すべての階層が最大限までノードで満たされている二分木と言える。
しかし、完全二分木という言葉は別の意味で使われることもある。
それは、最下層を除いて全ての階層がノードで満たされ、かつ最下層の葉ノードが左側から順に詰められている二分木のことを指す。
この意味での完全二分木（complete binary tree）は、可能な限りノードを詰め込んだ状態、つまり最大容量であることを意味する。

木構造を利用した探索

二分探索木とは、特定のルールに従った木構造のことを指す。二分探索木（ binary search tree）は、木の各ノードが「左の子孫の値 ≤ 親(x)の値 ≤ 右の子孫の値」という制約を持つ二分木のことを指す。
この二分探索木は、データの探索を簡単にするためのツール。探したい値（キー）が決まると、まずは根ノード（一番上のノード）から調査を始める。
根ノードの値とキーを比較し、もしキーが小さい場合は左側の子ノード、大きい場合は右側の子ノードへと探索を続ける。これをキーが見つかるまで繰り返し行う。

この繰り返しは再帰的に行われる。つまり、次に調査する子ノードを新たな「根ノード」とみなし、またそのノードの値とキーを比較するという手順を続ける。これにより、高速にデータを探索することが可能となる。

二分探索木の問題点として、左右のバランスが取れていない点が挙げられます。
完全な二分探索木は、高さが log nであることが保証されています。これは、二分探索の処理時間が O(log n) であることを意味している。
つまり、探索にかかる時間は木の高さに比例する。問題はバランスが取れていない二分探索木である。

平衡二分探索木

二分探索木の探索効率が最高になるのは、木の高さが最も低いケース。つまり、根ノードから各葉までの高さができるだけ等しくなった場合であり、
このような二分探索木は、「最もバランスが取れている」状態を指し、平衡二分探索木（self-balancing binary search tree）と呼ばれる。
バランスが取れているとは、木の各部分ができるだけ均等な高さになっている状態のことで、探索効率が最も良くなる。
つまり、探すデータがどこにあっても探すのにかかる時間がほぼ一定になるということ。平衡二分探索木の計算量は O(log n) になる。



