片方向リスト（singly-linked list）は、連結リストの中でも最も基本的な形態の一つ。
各ノードはデータを格納する変数（data）と、次のノードを指すポインタ変数（next）から構成されている。
次のノードを指すポインタは、リストの最後尾に達した場合には null 値を格納するか、空のリストを指すこともある。

重要な点として、ノードにおける next 変数には参照（メモリアドレス）が格納されていることに留意する必要がある。
実際に格納されるのは次のノードオブジェクトの参照であり、これを通じて次のノードにアクセスすることができるため、ポインタ（pointer）と呼ばれている。

Note: ポインタ
ポインタは、他の変数のメモリアドレスを格納する変数。
ポインタは、連結リストや木のような動的データ構造の実装によく使われ、また、特定のアルゴリズムの性能向上にも利用されることがある。
しかし、ポインタはメモリを慎重に管理する必要があるため、扱いがやや難しい場合がある。

連結リストにおいて、最初のノードは先頭（head）と呼ばれ、リストの最後のノードは末尾（tail）と呼ばれる。
先頭ノードを表す変数や参照が通常使用され、この変数を使用してリストの要素にアクセスする。
リストの最後のノードは通常、次のノードへの参照を持たず、null（または nil）という値が next に割り当てられる。
これにより、リストの終了が示される。null を持つノードを末尾ノードとして特定し、リストの末尾を判断することができる。

片方向リストで使える操作（挿入、削除、インデックス操作）について

連結リストのプラス面とマイナス面について。まずはインデックス操作。
連結リストは、要素がメモリ上で非連続的に配置されているため、要素にアクセスするためにはポインタをたどる必要がある。
そのため、連結リストのインデックス操作は、i 番目の要素に到達するために、i-1 番目までの全ての要素を辿る必要がある。
この操作は、最悪の場合、リストの長さに比例して O(n) の時間がかかる。

一方、配列では、データが連続的に格納されているため、インデックス演算は O(1) の時間計算量で実行できる。配列では、指定したインデックスに直接アクセスすることができる。
したがって、連結リストのインデックス操作は配列のインデックス操作よりも効率が悪いと言える。

挿入

配列はそのサイズが固定で、サイズを変更するには新しい、より大きな配列を作成する必要がある。
一方、連結リストは各ノードが次のノードへの参照（通常はポインタ）を持つシンプルなデータ構造を利用しており、これによりリストのサイズを容易に調整することが可能。
連結リストの特性を活用すれば、既知のノードの直後に新しい要素を挿入することは O(1) の時間計算量で可能。例えば、「A」というノードの直後に新しいノード「B」を追加するとき、以下のような手順となる。

まず、「A」の次のノードへの参照を、一時的に別の場所に保存します。この保存した参照を「T」と呼ぶ。
次に、「A」の次のノードへの参照を「B」に変える。
最後に、「B」の次の項目へのノードを、「T」に保存しておいた元々の「A」の次のノードに変える。
これらの手順により、「B」は「A」の直後に追加されることになる。

先頭へ挿入

リストの先頭と末尾への挿入は、先頭と末尾が追跡されていれば、常に O(1) で実行することができる。

末尾へ挿入

リストの最後に要素を追加するためには、片方向リストを辿ることによって O(n) で末尾を見つけることができる。
もし、片方向リストの末尾が追跡されている場合は、O(1) で適用することができる。

削除

片方向リストは、各ノードが次のノードへの参照を持つ構造。
そのため、リスト内を逆方向に移動するための直接的な機能がないため、特定のノードを削除する場合にはリスト上で線形探索を行う必要がある。

先頭のノードを削除する場合、そのノードの次のノードを新たな先頭として割り当てることで O(1) の時間で削除できる。
しかし、特定のノードを削除する場合には、そのノードがリスト上でどこに位置するかを見つける必要がある。これには、先頭から順にノードを調べる線形探索が必要。

したがって、特定のノードを削除する操作は、ノードが見つかるまでリストを順に探索する必要があります。この操作は O(n) の時間計算量がかかる。
