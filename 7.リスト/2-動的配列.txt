格納されている要素数に応じて、必要に応じて自動的に大きくしたり小さくしたりできるデータ構造として動的配列（dynamic array）が挙げられる。
動的配列は、新しい要素を追加するときに既存のメモリスペースが不足している場合、自動的により大きなメモリブロックを確保する。
そして、既存の要素を新しいメモリブロックにコピーします。この機能により、配列は効率的に大量の要素を取り扱うことが可能です。

一方、動的配列において要素が削除されるとき、実際には要素がメモリから物理的に削除されるわけではないことが一般的。
代わりに、配列の論理サイズ（要素数）がデクリメント（減少）され、要素が削除された場所は空きスペースとなる。この空きスペースは、新たに要素が追加される際に再利用される。

動的配列には、固定サイズ配列と比較していくつかの利点があり、主な利点のひとつは、配列のサイズや占有するメモリの量を気にすることなく、要素の保存やアクセスを効率的に行うことができる。
また、配列のデータを操作するためのさまざまなメソッドや演算子が用意されており、要素の挿入や削除、検索などを行うことができる。

動的配列の仕組み

それでは動的配列の仕組みについて詳しく見てみましょう。
動的配列では、配列の論理サイズ（logical size）と容量（capacity）というものが常にメモリ内で把握されている。
論理サイズとは、現在配列に格納されている要素数を表し、容量はサイズを変更する前に配列が保持できる最大要素数を表す。
動的配列に要素を追加し、要素数が容量を超えると、新しい要素を収容するために配列は自動的に大きなサイズにリサイズされる。

先頭への挿入
動的配列の先頭に要素を挿入するには、通常、既存のすべての要素を 1 つずつずらして、新しい要素のためのスペースを確保する必要がある。
これは特に配列が大きい場合には、時間のかかる操作となる。n 個の要素がある場合、n 個の要素を移動させる必要があるため、結果として O(n) の計算コストが必要になる。
動的配列の一番最初の要素にいきなり値を追加できないのは、すでにセルの中に値が存在していており、値を上書きしてしまうからです。

スロットに値をコピーするとは、メモリの中にあるセルの中に、値をコピーし格納することを指す。例えば、JavaScript では以下のような処理が行われている。
let copyValue = array[1];
array[1] = array[0];
array[0] = copyValue;
要素を 1 つ隣に移動するのに 3 回の計算が必要となるので、n 個の要素を移動するには 3n (= O(n)) 回の計算が必要になりる。


先頭の削除
一方、先頭の要素を削除する場合は、n-1 個の要素を 1 スロット後ろ方向に移動させる必要があるため、O(n) の計算コストが必要になります。
動的配列は、データ構造として固定長配列を使用して実装され、要素の追加や削除によって論理配列のサイズを変更する機能を提供します。しかし、この操作では、実際に固定長配列から要素を追加したり削除したりすることはありません。その代わり、必要なサイズの新しい配列を作成し、関連する要素を古い配列から新しい配列にコピーします。
動的配列に要素を追加する場合、配列の実装は通常、新しい要素を格納するのに十分な容量があるかどうかをチェックします。十分な容量がある場合は、単に配列の論理サイズを増加させ、次の使用可能なインデックスに新しい要素を格納します。もし十分な容量がない場合は、より大きな容量の新しい配列を作成し、古い要素と新しい要素を新しい配列にコピーします。
同様に、動的配列から要素を削除すると、配列の実装は単に配列の論理サイズをデクリメントし、削除された要素が残したギャップを埋めるために残りの要素を移動させることがあります。しかし、実際の要素は、その下にある固定サイズの配列から削除されるわけではありません。


途中への挿入
n 個の要素の動的配列の真ん中へ要素の挿入を行う場合、先ほど学習した先頭に要素を挿入する場合と同様の処理を配列の真ん中まで行えば良いことになります。したがって、0.5n 個の要素を移動させる必要があり、結果として O(n) の計算コストが必要になります。

途中の削除
一方、動的配列の真ん中から要素を削除する場合、0.5n - 1 回の移動が必要となるので、同様に O(n) の計算コストが必要になります。

末端への挿入
配列の末端に要素を挿入する処理は、先述した通り、配列の論理サイズと収容可能サイズとの兼ね合いで妥当な処理が実行される。
配列の容量が最大に達している、つまり「論理サイズ = 収容可能サイズ」の場合、新しい配列を作成し、もとの配列に入っていた n 個のデータと新しく追加したデータを合わせた計 n+1 個の要素を、その新しい配列にコピーする。
したがって、O(n) の計算コストが必要になります。しかし、ほとんどのケースでは、配列に余裕があるので、最後のスロットにデータを挿入するだけで済む。この場合は、計算コストが O(1) となります。

末端の削除
配列の末尾から要素を削除するのは簡単で、単純に O(1) の計算量が発生する。