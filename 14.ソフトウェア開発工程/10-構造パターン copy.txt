構造パターンは、クラスやオブジェクトをどのように組織化し、組み合わせて、より複雑な構造を形成するかを扱う。
構造化パターンは、集約、合成、継承、およびインターフェースを使用して、これらの大きな構造を作成する。

アダプタパターン（adapter pattern）
一つのクラスのインターフェースを、他のクラスが期待する形に変換するデザインパターン。
これにより、元々は互換性のなかったクラスやコンポーネントも、アダプターを介してスムーズに連携し、一緒に動作することが可能になる。
これは、コードの再利用を促進し、異なるシステムやライブラリ間での連携を容易にする。

ブリッジパターン（bridge pattern）
抽象化とその実装を分離し、それぞれが独立して変更できるようにするデザインパターン。
具体的には、あるクラスの機能やロジック（抽象化）と、それを具体的に実行する方法（実装）が密接に結びついていると、一方を変更した際に他方に影響を与えてしまう可能性がある。
これを防ぐため、ブリッジパターンを用いて抽象化と実装を分けることで、それぞれを独立に変更や拡張ができる構造を目指す。

コンポジットパターン（composite pattern）
個々のオブジェクトとオブジェクトのグループを同じ方法で扱うことができるようにする。
オブジェクトを木のような階層構造で整理して、単一のオブジェクトとオブジェクトの集まり（グループ）に同じ操作を行うことが可能になる。

デコレータパターン（decorator pattern）
オブジェクトに動的に追加の責任を付与することができるが、そのインターフェースは変更しない。
デコレーターパターンを使用すると、元のコードやクラスを変更することなく、オブジェクトに新しい機能を付け加えることができる。

ファサードパターン（facade pattern）
複雑なシステムやライブラリは、その多様性ゆえに多くのインターフェースやメソッドを持っており、それらを直接操作するのは複雑で手間がかかることがある。
そのような複雑な操作をシンプルにまとめ、ユーザーが簡単にアクセスできる一つのインターフェースを提供する役割を持っている。

フライウェイトパターン（flyweight pattern）
大量のオブジェクトを作成する必要がある状況で、メモリ使用量を減らし、パフォーマンスを向上させるために使用される。
フライウェイトパターンは、インスタンスごとに新しいオブジェクトを作成するのではなく、似たような特性を持つオブジェクトの状態を共有することでこの問題を解決する。
つまり、同じ特性を持つ複数のオブジェクトを作るのではなく、状態を共有した 1 つのオブジェクトを再利用するのがフライウェイトパターン。

プロキシパターン（proxy pattern）
元のオブジェクトの代用として機能するプロキシ（代理人）オブジェクトを作成することによって、オブジェクトへのアクセスを制御する方法を提供するもの。
コードで使いたいオブジェクトがあるが、何らかの理由で直接アクセスしたくないような場合に使用する。
プロキシオブジェクトは、元のオブジェクトと同じような外観と動作をしますが、キャッシュやロギングなどの追加機能を提供したり、元のオブジェクトへのアクセスを制限することができる。



