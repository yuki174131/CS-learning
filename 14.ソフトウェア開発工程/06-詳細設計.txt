システムの全体構造、コンポーネント、およびその相互作用の高水準の設計図としての役割を果たすのがアーキテクチャ設計。
これはシステムまたはサブシステムの広範なビジョンをキャッチする基盤的なステップ。しかし、ソフトウェア設計プロセスの一側面に過ぎない。
詳細設計はさらに深く掘り下げ、各モジュールやコンポーネントが入念に詳述される段階。
詳細設計は、ソフトウェアの品質と開発効率の向上の 2 つに結びついている。ソフトウェアが高品質と認められるためには、機能的・非機能的要件を満たすだけでなく、利害関係者の期待にも応えることが必要。
また、開発者はロジックの概念化や実装のアイディアをブレインストーミングすることが求められる。

ソフトウェアの品質
ソフトウェアの品質は、要求モデルに記載された全ての機能的及び非機能的要件を正確に実装し、さらに利害関係者の期待にも応えることを指す。
この理念は、既に全要件が定義されていると仮定される伝統的なウォーターフォールモデルのフェーズである詳細設計から、アジャイル開発のようにフィードバックループを持つ反復的なプロセスにも適用される。
アジャイル開発の文脈においては、設計はエンドユーザー、ターゲット市場、投資家といった利害関係者のニーズを中心に据えるべき。
アジャイルの開発サイクルは、反復を重ねる中で要件が逐次的に加えられたり、更新されたり、時には削除されたりする。そのため、ソフトウェアの高い品質を確実に維持するためには、確立されたベストプラクティスに従うことが不可欠。

開発効率
開発効率とは、ソフトウェアを開発・維持する際の効果的な取り組み方を指す。
詳細設計を行うことで、ロジックが具体的にどのように機能するかを考え、実装方法をアイデア出しする。
これにより、実装の観点から問題を解決する方法を考える自由が生まれ、作業を始める前に品質を保証できる。
詳細設計に十分な考慮をせず、またはそれをスキップすることは非効率。なぜなら、ソフトウェア開発のこの段階では開発コストが最も低い。
詳細設計中の実装変更にかかるコストは、コーディング中の実装変更に比べてほぼゼロ。実装変更にかかるコストは時間の経過とともに指数関数的に増加する。
コーディングが完了した後、品質保証（QA）中や本番リリース後の実装変更にかかるコストは、10 倍ずつ増加する。そのため、ソフトウェアを効率よく、低コストで開発するためには、詳細設計フェーズに時間をかけることが重要。

詳細設計
詳細設計には、コンポーネントレベルの設計と UI/UX 設計の 2 つのタイプが含まれている。
コンポーネントレベルの設計は、コンポーネントの構造、実装方法、および他のコンポーネントとの相互作用に関する詳細を提供する。
UI/UX 設計は、ソフトウェアとエンドユーザーとの間のインタラクションに関連する部分に焦点を当てている。
コンポーネントレベルの設計は、ユーザーには見えないソフトウェアの部分を主に取り扱っていますが、UI/UX はエンドユーザーに見える、また経験するソフトウェアの部分に焦点を当てている。
これらの詳細設計は並行して開発されることがあり、UI/UX の設計もコンポーネントレベルの設計に支えられている。
アーキテクチャはプロジェクトの初めやシステム全体のイテレーションで重点的に設計されるのに対し、詳細設計はソフトウェアに適用される各イテレーション、機能の追加、コンポーネントの更新やリファクタリング、コーディングが必要な作業に適用される。


コンポーネントレベルの設計
モジュールやサブシステムのような個々のソフトウェアコンポーネントを個別に設計・開発するソフトウェア開発プロセス。
各コンポーネントは特定の機能を念頭に置いて設計され、他のコンポーネントとの相互作用が定義される。
コンポーネントレベルの設計の目的は、モジュール化された再利用可能なソフトウェアコンポーネントを作成し、大規模なシステムに容易に統合してテストできるようにすること。
このアプローチにより、開発者は複雑なシステムをより小さく管理しやすいコンポーネントに分解することができ、ソフトウェアシステムの設計、実装、テスト、および保守が容易になる。
これらのコンポーネントが組み合わされると、ソフトウェアシステム全体が形成される。
コンポーネントはアーキテクチャが設定された後に設計される。各コンポーネントはアーキテクチャの個々の部分。また、コンポーネントはさらに小さなコンポーネントに分割することもできる。

コンポーネントを開発するための一般的な手順は、以下の通り。

Step 1
システムを管理しやすい小さなコンポーネントに分解する。

Step 2
コンポーネント間のインターフェースと相互作用を定義する。

Step 3
各コンポーネントの開発プロセスに従う。

（要件）コンポーネントの機能要件または目的を特定する。
（設計）各コンポーネントの内部構造を設計する。
（コード＆テスト）各コンポーネントを個別に実装し、テストする。
（デプロイメント）コンポーネントをより大きなシステムへ統合する。

Step 4
システム全体をテストして、コンポーネントがうまく統合されていることを確認する。

コンポーネントレベルの設計の初めのステップは、システムをコンポーネントに分解し、それらのコンポーネントがどのように相互作用するかを明確にすること。
このステップにおいて、コラボレーション図を作成し、各コンポーネントのインターフェースを開発する。これらのプロセスは同時に進行する。
コンポーネントの契約、別名インターフェースとしても知られているが、どの関数が利用可能であるか、入力/出力の値は何かを明示する。
場合によっては、契約は前提条件、後置条件、および例外も定義することができる。これにより、モジュールとして扱うことができ、維持管理が容易で、拡張性があることを保証するのに役立つ。

コラボレーション図
システム内のコンポーネント間で交換される相互作用とメッセージを視覚化するために使用されるダイアグラムの一種。
特定のタスクや機能を達成するために、オブジェクトが互いにどのように協力し合うかを示すもの。矢印はメッセージの流れの方向を示し、メッセージの名前とフロー番号でラベル付けされている。

コンポーネント図（UML）
システムのコンポーネントとその依存関係を示す図の一種で、ソフトウェアシステムの組織を高い抽象レベルで視覚化するために使用される。
システムの各部分は、特定の機能を実行する個別のコンポーネントとして示される。これらのコンポーネントはモジュール化されており、システムの他の部分や他のプロジェクトで簡単に再利用することができる。
システムが必要とする情報、作成する情報、アクセスする情報はすべてアーティファクト（artifact）と呼ばれる。

インターフェースクラス
インターフェースクラスは、インターフェースを実装するクラスが必ず持つべき抽象的なメソッドやプロパティのグループを定義した設計図。
コンポーネントが期待するオブジェクトの種類を指定するために使用される。インターフェースの主な目的は、システムの異なる部分の間で共通の合意や標準を確立すること。
インターフェースは抽象的であり、実装クラスが行うべきことを概説するだけで、それをどのように行うべきかの詳細を提供するものではない。

各コンポーネントがどのように相互作用し、公開インターフェースを持つかを理解し、レイアウトすることができれば、個々のコンポーネントを設計することができる。
個々のコンポーネントに取り掛かる前に、システムとコンポーネントを再帰的に分解し、個別に機能するコンポーネントレベルまで分解する。
最も低いレベルでは、コンポーネントの意味を明確に定義することができる。例えば、オブジェクト指向プログラミング（OOP）言語では、クラスがコンポーネントの一つとなる。

1 つのコンポーネントの詳細を決定するには、以下の 3 つのステップを踏む必要がある。

Step 1: 公開インターフェースの定義
これはコンポーネントやクラスを設計する際に非常に重要。これは基本的に、他のコンポーネントやクラスがこの特定のコンポーネントとどのように相互作用するかを定義するもの。
公開するメソッドは、外部に提供する振る舞いや機能を決定する。入力と出力のデータ型、そして関数の目的を記述することは重要。

Step 2: データ設計
コンポーネントの内部構造を理解することが重要。これは、OOP におけるカプセル化の考え方に通じるもので、オブジェクトの内部状態はプライベートに保たれ、他のオブジェクトやコンポーネントはそのパブリックメソッドを通じてオブジェクトと相互作用する。
カプセル化と再利用性を確保するために極めて重要。

Step 3: 各プロセスの手順の説明
コンポーネント内の各プロセスが単一のタスクに焦点を当てるようにすることで、コンポーネントがより保守しやすくなり、テストも容易になる。
コンポーネント内の各プロセスや機能が具体的にどのように計算や処理を行うのかの手順を策定する。アクティビティ図やフローチャートを使用して、これらのステップを視覚化すると、設計、レビュー、共同作業が容易になる。

この段階では、UML クラス図を使って詳細を示すことが一般的です。その結果として、クラスの概要、クラス変数、インスタンス変数、メソッドなどの基本構造を示す分析クラスを作成できる。

分析クラス（analysis class）
ソフトウェア開発の初期段階での設計プロセスにおいて使用される概念。この段階では、実際のプログラムを書く前に、システムが対処すべき問題や要件を理解し、それをオブジェクト指向のクラスの形式に落とし込む作業を行う。
エンティティが持つべきデータや属性、そしてそれらのデータに対して行うべき操作やメソッドを特定したり、どのクラスが他のクラスとどのように関連するのか、または相互作用するのかを理解し、それをモデルに反映することも含まれる。
https://gyazo.com/5652b972a37007a163020a7e8809dbe1
分析クラスを作成した後は、全ての変数やメソッドの詳細なリストと、関係（集約や組成）の完全な詳細を持つ、詳細設計クラスを作成することができる。

詳細設計クラス（elaborate design class）
分析クラスから派生したもので、分析クラスの属性や操作だけでなく、可視性、アクセス制御、継承、インターフェース、必要なデータ構造やアルゴリズムなどの追加の詳細も含まれる。
設計クラスは、オブジェクト間の関係（継承、コンポジション、関連）の実装も担当している。
https://gyazo.com/ce8a2dfbbbdb4afd90c867248045dfa6


最終ステップは、各プロセスの手順的な説明を作成すること。この段階では、特定の方法に注目し、そのプロセスがどのように進行するかを手順毎に詳細に書き出す。
全ての前提条件や後条件、例外、性能に関する制約、そして具体的な入出力値を明記する。このプロセスの説明には、アクティビティ図が役立つ。
データ構造やアルゴリズム、プログラミングの経験は、この手順の詳細や制約を理解するのに有効。さらに、前提条件やプロセスが呼び出される前後の状態などの詳細が必要な場合は、状態図を用いることが推奨される。
特に、エントリーポイントの関数や while ループのように、複数のイベントや状態を持つ複雑な関数に対しては非常に役立つ。

アクティビティ図
アクティビティ図は、機能に関わるアクティビティの流れを入力から出力まで示している。機能の要件と目的を検討した後、機能は個々のステップ、アクティビティに分解される。

状態図
システムの動作を異なる状態やそれらの状態間の遷移に分けて視覚的に表現したもの。
状態は遷移でつながれており、これはシステムがトリガーに応じて状態間を移動する方法を示す。アクションは状態と遷移の両方に関連付けることができ、これらのアクションはシステムが特定の状態に入る、または退出する時、あるいは状態間で遷移する時の動作を表す。

この設計段階を利用して、要件をソフトウェアコードにどのように変換するかを探求する


デザインパターン
ソフトウェアを設計する際、品質と実装効率を向上させるための核となるコンセプトが存在する。

抽象化（abstraction）
ソフトウェア工学において、開発プロセスを簡略化するために用いられる技法。システムの最も重要な機能を特定し、無関係な細部を無視。
これにより、開発者はより理解しやすく、使いやすいモデルやインターフェースを作成することができる。

関心の分離
関心の分離（separation of concerns）とは、複雑なシステムをより小さく、より管理しやすい部分に分割し、それぞれが特定の責任を持つようにすることです。これにより、複雑さを軽減し、モジュール性を高め、システムの保守と修正を簡素化することができます。

凝集性（cohesion）
モジュールやコンポーネントの要素がどれだけ互いに関連しているかを意味する。結合力の高いモジュールには、明確で集中した目的があり、すべての要素がその目的を達成するために協力し合う。
結合度（coupling）とは、モジュールやコンポーネントが互いにどの程度依存しているかを意味する。結合度の低いモジュールは独立性が高く、システムの他の部分に影響を与えることなく修正や置き換えが可能。
ソフトウェアシステムは、高凝集と低結合を持つことを目標とする必要がある。

モジュール性（modularity）
システムを独立したモジュールに分割し、それぞれを開発、テスト、保守することでシステムを構成する方法。このアプローチにより、柔軟性、拡張性、保守性が向上する。

拡張性（extensibility）
ソフトウェアシステムを拡張したり変更したりして、新しい機能や特徴を追加することが容易であることを指す。

情報隠蔽（information hiding）
モジュールやコンポーネントの実装の詳細をシステムの他の部分から隠すことを指す。これにより、開発者はシステムの残りの部分に影響を与えることなく、モジュールの実装を変更することができる。
カプセル化と同様に、コントラクトやインターフェースがよく使われる。

独立性（independence）
システムの異なるコンポーネント間で、機能面でも実装面でも、どの程度隔離されているかを示すもの。これにより、複雑さを軽減し、柔軟性を高めることができる。

リファクタリング（refactoring）
コードの動作を変えずに、品質と保守性を向上させるためにコードを再構築するプロセスのこと。リファクタリングでは通常、コードを単純化し、重複を減らし、モジュール性と可読性を向上させるための変更を行う。

また、ソフトウェアエンジニアが共通して守るべき原則もあります。

DRY（Don't Repeat Yourself）
開発者は可能な限りコードの重複を避けるべきという慣習。DRY の背景にある考え方は、コードを DRY に保つことで、開発者が書くべきコードの量を減らし、コードの保守性を向上させ、コードを拡張する必要がある場合に不要な作業を避けることができるというもの。

KISS（Keep It Simple Stupid）
ソフトウェア設計におけるシンプルさの重要性を強調するもの。開発者が物事をシンプルに保つことで、コードが読みやすくなり、複雑さが軽減され、バグが発生するリスクを最小限に抑えることができる。

YAGNI（You Ain't Gonna Need It）
開発者は絶対に必要な機能だけを追加するように気をつけるという慣習。必要な機能と要件に集中することで、開発者は開発期間とコストを削減し、複雑さを軽減してコード品質を向上させることができる。
要件を分析することと、必要に応じてコードベースを拡張できるようにソフトウェアを設計することの間で、適切なバランスを見つけることが重要。これは、アジャイル開発環境では特に重要。




