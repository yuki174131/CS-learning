
初期のプロトタイプや開発において、最も重要なのは、ソフトウェアのアーキテクチャを考えること。
この段階では、システム全体の全体像について考える。アーキテクチャが決まれば、コードベース全体はそれを中心に開発されることになる。

アーキテクチャを考える際には、以下のような重要な要素を考える。

システム要件
システム要件は、ソフトウェアが何を行い、どのような機能を持つ必要があるかを説明する。アーキテクチャは、これらの機能要件、非機能要件を満たすように設計される必要がある。

スケーラビリティ（拡張性）
「システムが大きく成長するとき、問題なく対応できるか」というのがスケーラビリティのポイント。具体的には、将来的にユーザーが増えたり、データの量が増えたりした場合、システムはその増加をスムーズに処理できるかということ。
そのための技術や方法として、水平スケーリングなどがる。
1,000 人から 10 万人のユーザーを想定したシステムは、数千万人のユーザー向けのシステムとは大きく異なる。同様に、1 秒あたり 100MB 〜 1GB のデータを処理するシステムは、1 秒あたり数百テラバイトのデータを処理するシステムとも大きく異なる。

保守性
アーキテクチャは保守性のために設計される必要がある。つまり、システムに必要な変更やアップデートを容易に行えるようにする必要がある。全体的なシステムに支障をきたさずに変更ができることが求められる。
これは全てのシステムに共通する要件であり、そのために一般的なソフトウェアのベストプラクティスが採用される。具体的には、低い結合度、高い凝集度、そして自己文書化されたコードなどが重視される。

セキュリティ
ソフトウェアアーキテクチャは、セキュリティを考慮して設計される必要がある。これには、攻撃からシステムを保護すること、データのプライバシーと整合性を確保すること（正確で一貫性のあるデータ、データ損失の防止）、
関連する規制に準拠することなどが含まれる。システムによってはセキュリティの制約が異なる場合もありますが、すべてのシステムで最低限のセキュリティを考慮する必要がある。

パフォーマンス
アーキテクチャは、システムがタイムリーかつ効率的に機能を実行できるように、高いパフォーマンスを発揮できるように設計する必要がある。規模や段階に応じて、開発前に性能要件を設定し、ソフトウェアがスケールするにつれて、システムのスケールに合わせて最小要件のベンチマークとして機能させることができる。

統合性
ソフトウェアアーキテクチャは他のシステムやアプリケーションと容易に統合できるように設計する必要があり、システムがエコシステムの他の部分と相互作用できることを保証する必要がある。

技術スタック
アーキテクチャに使用する技術スタックは、プラットフォーム、信頼性、保守性、使いやすさなどの要素を考慮し、慎重に選択する必要がある。
開発チーム。アーキテクチャは、開発チームを念頭に置いて設計する必要があり、チームのスキルや専門性に合わせて、開発チームが実装できるようにする必要がある。

開発チーム
アーキテクチャは、開発チームのスキルと専門知識に合わせて設計される必要がある。そして、チーム自身が実装できるようにすることが重要。


ソフトウェアを設計するための様々な知識が蓄積されるにつれて、ソフトウェア業界では、あるパターンが常に現れるようになった。
これらのパターンは、建築のスタイルの違いのようなもの。家が倉庫や教会と違って見えるように、ソフトウェアシステムもその目的によって異なるアーキテクチャを持つ。
アーキテクチャースタイル（architecture style）とは、ソフトウェアシステムの構造全体がどのように構成されるべきかを指示する、一般的なガイドラインと原則のセット。
このスタイルは、システムのコードベース全体またはその一部に対して一貫して適用される。

データ中心型アーキテクチャ（data centered architecture）
データが中心となり、アプリケーション、サービス、インターフェースなどの他のシステムコンポーネントは、データとの連携や操作を目的として設計される。
このアプローチにより、データが常にシステムの最も重要な要素であり、他のコンポーネントがデータの管理と使用をサポートするために設計されていることが保証される。
例: ChatGPT、検索エンジン

データフローアーキテクチャ（data flow architecture）
システムは独立したコンポーネントの集合体として設計され、各コンポーネントが特定の機能を担当し、データはこれらのコンポーネント間を流れる。
データフローアーキテクチャは、リアルタイムシステム、信号処理システム、分散システムなど、大量のデータを処理する必要があるシステムでよく使われる。
このアーキテクチャの主な利点は、必要に応じてコンポーネントを追加または削除することでシステムの拡張が容易になること。
データフローアーキテクチャでは、データの流れを直線的なパイプラインとして表現することが一般的。
データは一つのコンポーネントから次のコンポーネントへと順次渡され、各コンポーネントはデータを変換、処理、分析、または他の操作を行う。このようなパイプラインの構造により、データの処理が効率化され、柔軟性や拡張性が向上する。
例: TypeScript トランスパイラ、Web クローラ

コール・アンド・リターンアーキテクチャ（call-and-return architecture, CRA）
プログラムは主に手続きや関数と呼ばれる小さな処理単位に分割される。プログラムの実行は、メインのプログラムから手続きを呼び出し（コール）、
呼び出された手続きが処理を行った後にメインのプログラムに戻る（リターン）という流れで進む。
このアーキテクチャは、同一システム内の手続き型プログラムや関数呼び出しで使用される場合と、異なるシステム間でのリモートプロシージャコール（RPC）アーキテクチャで使用される場合がある。
後者では、ネットワークを介して別のシステムのプロシージャを呼び出し、処理結果を受け取る。
例えば、CLI は、ユーザーがテキストベースのコマンドを入力し、それに対応するプログラムや機能を呼び出すインターフェース。ユーザーがコマンドを入力すると、メインプログラム（シェル）がそれを受け取り、
関連するサブプログラム（コマンド）を呼び出す。サブプログラムが処理を完了すると、制御はメインプログラムに戻り、新たなコマンドの入力待ち状態になる。

レイヤードアーキテクチャ（layered architecture）
アプリケーションを論理的なレイヤーに分割し、各レイヤーが特定の機能を提供する。通常、レイヤーは階層的に配置され、各レイヤーは下のレイヤーに依存する。
レイヤーが上に行くほど、ユーザーに近くなる。一方、レイヤーが下に行くほど、オペレーティングシステムやデータベースに近くなる。
例: TCP/IP プロトコル

イベント駆動アーキテクチャ（event-driven architecture）
システム内で何かイベント（特定の出来事）が発生した時、そのイベントに関連するソフトウェアの部品同士が、互いに非同期（同時ではなく順不同で）に通信し合って動作する仕組みのことを言う。
明示的な要求（リクエスト）に頼るのではなく、イベントが起こった時に自動的に対応する。
例えば、ゲームはイベント駆動アーキテクチャを使用することが一般的。ゲームでは、プレイヤーの入力やキャラクターの動き、衝突やトリガーの発生など、さまざまなイベントが発生する。
これらのイベントに応じて、ゲームエンジンやゲーム内のオブジェクトが適切なアクションを実行する。イベント駆動アーキテクチャは、ゲーム開発において柔軟性と拡張性を提供する。
ゲーム内の様々な要素（キャラクター、オブジェクト、エフェクトなど）は独立したコンポーネントとして扱われ、イベントを介して相互作用する。
これにより、新しい要素を容易に追加したり、既存の要素を修正したりすることができる。
例: サードパーティとの連携サポート

クライアントサーバアーキテクチャ（client-server architecture）
クライアントと呼ばれるアプリケーションがサーバと呼ばれる別のアプリケーションに対してリソースやサービスを要求する。
例えば、ウェブブラウザがクライアントであり、ウェブサーバがサーバとなる。
例: オンラインゲーム、ソーシャルネットワークサービス

サービス指向アーキテクチャ（service-oriented architecture, SOA）
ソフトウェアシステムを独立したサービスに分割し、それらのサービス間の連携と通信を可能にするアーキテクチャのアプローチ。
各サービスは、特定の機能を提供し、他のサービスと組み合わせて大規模なシステムを構築するために使用される。
SOA を利用することで、開発者は、開発、保守、更新が容易なソフトウェアシステムを構築することができる。なぜなら、各サービスは、システムの他の部分に影響を与えることなく独立して開発することができる。
これは、すべてを自分でやろうとするのではなく、プロジェクトの特定の部分にそれぞれ集中できる、専門的な労働者のチームを持つようなもの。
例: クラウドコンピューティングサービス

ピア・ツー・ピアアーキテクチャ（peer-to-peer architecture）
ネットワーク上のコンピュータシステムやアプリケーションの間で直接的な相互接続を可能にする分散型のアーキテクチャ。
このアーキテクチャでは、コンピュータ（ピア）同士が対等な地位で通信し、リソースや情報を共有できる。
P2P アーキテクチャでは、中央集権的なサーバが必要なく、各ピアが自己組織化されたネットワークを形成する。ピアは同時にクライアントとサーバの役割を果たし、他のピアに対してリソースを提供することができる。
データやファイルはピア間で直接転送され、ピアが相互にリクエストや応答を行う。
例: ブロックチェーン

記載されていないさまざまなスタイルが存在し、新たな発見やトレンド、ニーズに応じて新しいスタイルが続々と現れる可能性がある。
ネットワークや分散システムのようなサブシステムのシステムの場合、複数のアーキテクチャスタイルが適用されることがある。
分散システム全体の俯瞰図から見たアーキテクチャスタイルは一つである一方、各サブシステムやコンポーネントは独自のアーキテクチャを持っている。

アーキテクチャパターン
具体的な問題を解決するためのルールやガイドラインのセット。つまり、特定の要件や制約を満たすために確立された方法。
アーキテクチャパターンは、実践的な経験に基づいて検証され、効果的な解決策として認められている。
一般的には、まず問題に適したアーキテクチャスタイルを考え、それに応じてアーキテクチャパターンを選ぶことがある。
あるいは、既に解決済みの問題に対して有効なアーキテクチャパターンが存在する場合は、それを直接利用することもできる。
アーキテクチャパターンには、特定の名前が付けられており、デザイナー間のコミュニケーションに役立つ。これらのパターン名は、多くの意味を含んでいるため、設計者が効果的に情報を伝えるのに役立る。

よく遭遇するアーキテクチャパターン。

パイプとフィルタのアーキテクチャ（pipes and filters architecture）
データを小さな部分に分けて段階的に処理するソフトウェアの設計手法。
この設計では、データは「フィルタ」という部品を経由して流れる。それぞれのフィルタはデータに特定の処理を加え、その後「パイプ」を通じて次のフィルタへデータを送る。
各フィルタは独立して設計やテストができるため、変更や取り替えがシステム全体に影響せずにスムーズに行える。
アーキテクチャスタイル：データフローアーキテクチャ
使用例：データ処理ソフトウェア、バッチ処理システム、ETL（extract, transform, load）など

多層アーキテクチャ
ソフトウェアアプリケーションを、それぞれが特定の機能を持つ異なる層に分割して整理する方法。これは、アプリケーションがサーバ上で動作し、ユーザーがクライアントを介してアプリケーションとやりとりするクライアントサーバモデルでよく使用される。
層（ティア）の数は、アプリケーションの複雑さに応じて変えることができる。
3 層アーキテクチャは、アプリケーションをプレゼンテーション、ビジネス、データストレージの 3 つの層に分離する、多層アーキテクチャの特定のタイプ。
プレゼンテーション層は、Web ページやモバイルアプリのように、ユーザーに情報を表示する役割を担います。ビジネスロジック層は、データを処理し、アプリケーションのルールやロジックを実装する役割を担う。
データストレージ層は、データベースなどからのデータの保存と取得を担当する。3 層アーキテクチャでは、ユーザーが操作するコードであるクライアント、ビジネスロジックのコードを含むバックエンドサーバ、アプリケーションで使用するデータを格納するデータベースの 3 つの主要コンポーネントが存在する。
N 層アーキテクチャは、3 層アーキテクチャを拡張したもので、より大きなスケーラビリティを可能にするために、層をさらに細分化することができる。
例えば、メッセージング、個別サービス、ミドルウェア、サードパーティーの統合などのために、さらに層を追加することができる。これにより、アプリケーションはより柔軟になり、ニーズの変化に対応できるようになる。
アーキテクチャスタイル：レイヤードアーキテクチャ、クライアントサーバアーキテクチャ
使用例：ウェブサイト、モバイルアプリ、オンラインゲーム、IoT システム

MVC アーキテクチャ（model-view-controller architecture）
ソフトウェアをモデル、ビュー、コントローラの 3 つの部分に分けて組織化する方法。
モデルは、アプリケーションのデータとロジックが格納される場所です。つまり、モデルはアプリケーションのデータを管理・操作する役割を担っている。
ビューは、モデルからのデータをユーザに表示する責任を持つ。ここで、ユーザはアプリケーションのユーザインタフェースとやりとりすることになる。
コントローラは、モデルとビューの間の橋渡しのようなものです。コントローラはユーザの入力を処理し、それに応じてモデルやビューを更新する。コントローラはユーザからの入力を受け取り、それをモデルに送ってデータを更新し、そしてビューを更新してユーザに新しい情報を表示する。
MVC を使用することで、アプリケーションをモジュール化し、保守を容易にし、理解しやすくすることができる。データ、ユーザーインターフェース、制御ロジックを異なるコンポーネントに分離することで、他のコンポーネントに影響を与えることなく、各コンポーネントの変更や更新を容易に行うことができる。
アーキテクチャスタイル：レイヤードアーキテクチャ
使用例：ユーザーインターフェースを持つアプリケーション（Web、モバイル、デスクトップアプリ）

マイクロサービスアーキテクチャ（microservices architecture）
アプリケーションを小さな独立したサービスの集合体として開発するソフトウェア設計パターン。
これらのサービスは軽量なプロトコルを使用してネットワーク上で互いに通信し、各々が自己完結型で特定のビジネスタスクや機能を実行する。
また、他のサービスとは独立して開発、展開、スケーリングが可能。
これらのサービスは自律的で分散化されているため、障害箇所に対して耐性を持ち、必要に応じてスケールアップやスケールダウンが可能。
ソケット（または HTTP）を介した通信やリモートプロシージャコールを行う際に、すべてのサービスが同じプロトコルを知っているため、
それぞれのサービスは異なるプログラミング言語やテクノロジースタックを使用して開発することができ、技術に依存しない。
アーキテクチャスタイル：サービス指向アーキテクチャ
使用例：エンタープライズアプリケーション、中・大規模クライアントサーバ、データセンター、サードパーティサービス統合、クラウドコンピューティング

Blackboard アーキテクチャ（blackboard architecture）
異なるモジュールが共同で問題に取り組むためのソフトウェア設計方法。モジュールはすべて、Blackboard と呼ばれる共有データ構造にアクセスし、更新することができる。
Blackboard は、異なるナレッジソースやコントーラが情報を交換し、問題解決のために協力し合う中心的なハブとして機能する。
アーキテクチャスタイル：データ中心型アーキテクチャ
使用例：A.I システム、意思決定支援システム、自然言語処理、エキスパートシステム

メディエータートポロジーアーキテクチャ（mediator topology architecture）
システムのさまざまな部分で発生したイベントがまずイベントキューに送られるようにシステムを組織化する方法。次に、イベントメディエーターと呼ばれる中央のコンポーネントが、どのイベントをどのような順序で処理すべきかを決定する。
メディエーターは、各イベントプロセッサで処理されたイベントを新たに生成することもできる。
アーキテクチャスタイル：イベント駆動型アーキテクチャ
使用例：非同期トランザクション、金融取引システム、電子商取引アプリケーション、ソーシャルネットワークサービス

ブローカートポロジーアーキテクチャ（broker topology architecture）
イベント駆動型アーキテクチャにおける一種の構造です。この構造では、メッセージブローカーまたはイベントバスがシステム内の他のコンポーネントから送信されるすべてのイベントを受け取り、イベントチャネルと呼ばれるものに格納する。
その後、メッセージブローカーはイベントの内容に基づいて、それぞれのイベントが適切なイベントチャネルに送られるようにルーティングする。
各イベントプロセッサは、受け取ったイベントを処理し、新しいイベントを生成して再びメッセージブローカーに送信する役割を担っている。このプロセスでは、イベントの処理順序を調整するための仲介者や、処理後に新しいイベントを生成するためのメカニズムは存在しない。
その結果、一連のイベントが順番に発生することがよくある。
アーキテクチャスタイル：イベント駆動型アーキテクチャ
使用例：非同期トランザクション、金融取引システム、電子商取引アプリケーション、ソーシャルネットワークサービス

マスタースレーブパターン（master-slave pattern）
分散システムのアーキテクチャの一種で、マスターと呼ばれるデバイスまたはプロセスが、スレーブと呼ばれる他のデバイスまたはプロセスを制御します。マスターはシステム全体の動作を制御し、スレーブはマスターから割り当てられた特定のタスクを実行する。
スレーブノードは互いに直接通信することはできず、代わりにマスターノードを介して通信する。
アーキテクチャスタイル：メイン-サブルーチンアーキテクチャ
使用例： データベースレプリケーション、Web クラスタ、並列計算、ロボティクス

すべての解決策には独自の利点と欠点が伴う。アーキテクチャの設計においては特にその傾向が強い。一部のアーキテクチャは、開発の複雑さを受け入れることでスケーラビリティの向上を期待できる一方、シンプルなアプローチは迅速な実装を可能にするものの、スケーラビリティの面で制約が生じる場合がある。
また、ストレージの使用量を増加させることでパフォーマンスの最適化を図る設計や、大規模システムでの即時メッセージ配信を重視するアーキテクチャは、一貫性の確保に課題を持つことがある。
各ソリューションの長所と短所を確認し、プロジェクトの要件と比較することが重要。要件によっては、特定の長所が必須である場合もあれば、要件がなくても特定の短所には大きな影響がない場合もある。
決定する前に、ソリューションの短所が最低要件を満たしているかどうかを必ず確認することは重要。
アーキテクチャはシステム全体に関わるものであるため、各ソリューションについて慎重に検討することが重要。特定のパターンが最適なソリューションかどうかわからない場合は、少なくとも 1 つの代替アーキテクチャーのソリューションと比較するのが常によい。