行動パターンは、オブジェクトやクラスがどのように相互作用して特定の行動を実現するかに焦点を当てたデザインパターンのグループ。

責任連鎖パターン（chain of responsibility pattern）
複数のオブジェクトがリクエストを処理することを可能にする。リクエストは連鎖的に次のオブジェクトに渡され、どれかのオブジェクトがリクエストを処理するまで連鎖が続く。
具体的には、一つのリクエストが最初のオブジェクトに送られ、それがリクエストを処理できる場合は処理を行う。もし処理できない場合は、リクエストは次のオブジェクトに渡され、このプロセスがリクエストが処理されるまで続く。

コマンドパターン（command pattern）
アクションのリクエストとそのアクションを実行するオブジェクトを分離する。リクエストをオブジェクトとしてカプセル化することで、異なる引数でパラメータ化したり、異なるタイミングで実行したりすることができる。
このパターンでは、リクエストと関連するパラメータをカプセル化した Command オブジェクトと、Command オブジェクトを呼び出してリクエストを実行する Invoker オブジェクトに分離される。
Command オブジェクトは、実行した操作を元に戻したり、やり直したりする機能を持つことができ、undo/redo 機能の実装に有用。

インタープリタパターン（interpreter pattern）
特定の言語で書かれた文を解釈して実行する方法を提供します。例えば、計算式やプログラムコードなど、ある特定の言語で表現された「文」を、それを理解して処理できるようにするためのパターン。
具体的には、独自の小さな言語を作成して、それを用いて特定のタスクを解決するケースがある。インタープリタパターンは、その言語で書かれた文や命令を、プログラムが理解して実行できるようにする役割を持っている。

イテレータパターン（iterator pattern）
コレクションの要素に順番にアクセスする方法を提供し、その基礎となる実装を公開せずに済むようにする。イテレータパターンを使用すると、コレクションの内部構造を知らなくても、その要素を効率的に探索できる。
これは、配列、リスト、木構造など、さまざまなデータ構造に対して同じインターフェースでアクセスできるようにするためのパターン。

メディエータパターン（mediator pattern）
メディエータと呼ばれるオブジェクトを定義し、他のオブジェクト同士のコミュニケーションの仲介役として動作させるもの。
オブジェクト同士が直接コミュニケーションを行うのではなく、メディエータにメッセージを送り、メディエータが適切なオブジェクトまたはオブジェクトにメッセージを転送する。
メディエーターパターンの利用により、オブジェクト同士の依存関係が緩和され、それぞれのオブジェクトが独立して動作することができる。
これにより、システムの柔軟性とメンテナンス性が向上し、オブジェクトの再利用も容易になる。

メメントパターン（memento pattern）
オブジェクトの内部状態をカプセル化を侵害することなくキャプチャして保存し、後で必要に応じてその状態を復元する方法を提供する。
このパターンは、元に戻す・やり直す機能の実装や、オブジェクトの状態を特定のポイントでチェックして、状態の変更やエラーから復元する必要がある場合によく使われる。

オブザーバパターン（observer pattern）
オブジェクト間に一対多の関係を定義し、あるオブジェクトの状態が変わった際に、その依存オブジェクトすべてに自動的に通知して更新される仕組みを提供する。
これは「パブリッシュ/サブスクライブ」としても知られている。
このパターンは、オブジェクトの状態の変化を他のオブジェクトに効率的に伝える必要がある場合、特にリアルタイムでの更新が求められる場合に有効。
これにより、システム内のオブジェクトが互いに密に結びつくことなく、状態の変更を効率的に管理と共有することができる。

ステートパターン（state pattern）
オブジェクトの内部状態が変更された際に、そのオブジェクトの振る舞いを変更させることができる。これにより、オブジェクトがクラスを変更したかのように見る。
このパターンにより、状態に依存したコードを各状態のクラスにカプセル化することができ、メインのオブジェクト自体は、状態の変更によって振る舞いを変更することができる。

ストラテジーパターン（strategy pattern）
アルゴリズムの家族を定義してカプセル化し、それらを互換性を持って交換可能にするもの。異なるアルゴリズムが使用されても、クライアントは同じ出力を受け取ることができる。
具体的には、ストラテジーパターンを使用すると、特定のタスクを実行するための複数のアルゴリズムや方法を、同一のインターフェースまたは抽象クラスにカプセル化して定義する。
クライアントは、このインターフェースまたは抽象クラスを通じてアルゴリズムを利用するため、アルゴリズムの内部実装に依存することなく、同じ方法でタスクを実行することができる。

テンプレートメソッドパターン（template method pattern）
スーパークラスでアルゴリズムの骨格を定義し、サブクラスでそのアルゴリズムの特定のステップをカスタマイズできるようにするもの。
これにより、アルゴリズムの構造自体は変更せずに、その一部を変更・拡張できる。

紹介したパターンは、OOP を利用する多くのソフトウェア開発で適用され、非常に知られていて人気のあるデザインパターン。
しかし、デザインパターンはそれだけに留まらない。ソフトウェアのすべてのドメインやタイプには、それぞれのカテゴリのパターンが存在する。

いくつかのパターンは特定のドメインに特有であり、使用されるプラットフォームによって異なる実装になる可能性がある。
例えば、MVC アーキテクチャパターンは、フロントエンドしかない Web アプリケーションでは、サーバサイドの実装と比較して異なる実装になる可能性がある。
一方、ビデオゲームプログラミングのためのゲームループパターンのように、特定のカテゴリに特化したパターンもある。

これらのパターンは、開発の効率を向上させ、コードの再利用性を促進し、システムの保守と拡張を容易にする役割を果たす。
それぞれのドメインやプラットフォームに特化したパターンを学ぶことで、より効果的にソフトウェアを設計、開発することが可能になる。



